<!DOCTYPE html>
<!-- 
	DOM sprite demo
	by Christer Kaitila
	http://mcfunkypants.com
	http://twitter.com/McFunkypants
	http://google.com/+ChristerKaitila
	
	Created for Build New Games (c) 2012 by Bocoup
	http://www.buildnewgames.com
	
	Permission is granted to use this source code
	in any way you wish, commercial or otherwise. Enjoy!
-->
<html lang="en">
<head>
<title>DOM sprite demo</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<style type="text/css">
	body { margin:0; padding:0; border:0; background:black; overflow:hidden; }
	div { position:absolute; margin:0; padding:0; border:0; outline:0; 
		font-family:arial; font-size:12px; color:white; text-align:center; }
	#header { width:100%; top:24px; left:0px; }
	#header a { color:white; }
	#stats { width:100%; bottom:24px; left:0px; }
	#playbutton { position:absolute; top:50%; left:50%; margin-left:-137px; 
		margin-top:-25px; width:256px; height:32px; padding:16px; border-radius:16px; 
		border:2px solid black; background:#666666; color:white; 
		text-decoration:none; display:block; font-size:32px; line-height:32px; 
		font-family:arial; font-weight:bold; text-align:center; }
	#playbutton:hover { background:red; }
	#viewport { width:100%; height:100%; overflow:hidden; 
		top:0%; left:0%;}
	#level { width:2048px; height:100%; top:0px; left:0px; }
	#background { width:100%; height:100%; top:0px; left:0px; 
		background:url(bgtile.jpg); }
	.sprite { background-image:url(spritesheet.png); width:1.5%; height:3%; }
	.mouth {background-color:black;width:50px;height:100px;left:5%;top:45%;}
</style>
<script type="text/javascript" src="jquery-1.6.4.min.js"></script>
<script type="text/javascript" src="jquery-collision.min.js"></script>
</head>
<body>

<div id='header'>
HTML5 dom sprite rendering benchmark - 
Not using canvas: each sprite is a DIV - 
by <a target='_parent' href='http://twitter.com/McFunkypants'>McFunkypants</a> - 
Icons by Ails (cc)</a></div>

<div id='viewport'><div id='background'><div id='level'></div></div></div>

<a id='playbutton' href='javascript:startBenchmark()'>Click to start</a>

<div id='stats'></div>

<script type='text/javascript'>

// grab the DOM elements we want to manipulate
var viewport = document.getElementById('viewport');
var level = document.getElementById('level');
var background = document.getElementById('background');
var stats = document.getElementById('stats');
var playbutton = document.getElementById('playbutton');
var mouth = new Mouth();


 $(viewport).bind("mousemove", function(event) {	
			mouth.y=event.pageY;
		  });
		 
 $(viewport).bind("touchmove", function(event) {	
			event.preventDefault();

		    var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];

			mouseY = Math.floor(touch.pageY);
			mouth.y=mouseY;
		  });


		 
		  
 function collides(a, b) {
          return a.x < b.x + b.width &&
            a.x + a.width > b.x &&
            a.y < b.y + b.height &&
            a.y + a.height > b.y;
        }
		
function handleCollisions(){
var j =1;
if (j< sprites.length) {

		for (var i = 0; i < sprites.length; ++i) {
			 if(collides(sprites[i],mouth)){
					  sprites[i].xSpeed = -1 * sprites[i].xSpeed;
					}
		}

}
 }
// size of the the viewport and the larger level within
var viewportW = viewport.clientWidth;
var viewportH = viewport.clientHeight;

// sprite batches - one for moving sprites 
// and another for static level geometry
var sprites = [];
var spriteCount = 0;



// SPRITESHEET: all sprite frames stored in a single image
var spritesheetWidth = 256;
var spritesheetHeight = 256;
var spritesheetFrameWidth = 32;
var spritesheetFrameHeight = 32;
var spritesheetXFrames = spritesheetWidth / spritesheetFrameWidth;
var spritesheetYFrames = spritesheetHeight / spritesheetFrameHeight;
var spritesheetFrames = spritesheetXFrames * spritesheetYFrames;

// can this web brower handle CSS3 transforms (to trigger HW accel?)
var has3d = ('WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix());
if (window.console) console.log ('Browser is capable of CSS3 transform3d:'+has3d);
// but should we use it?
var use3d = false;

// ensure that we have requestAnimationFrame
// this is Paul Irish's compatibility shim
if (!window.requestAnimationFrame) 
{
	window.requestAnimationFrame = (function() 
	{
		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function(callback,element) 
		{
			window.setTimeout(callback, 1000 / 60);
		};
	})();
}

// add or remove sprites depending on the FPS
function maybeMoreSprites()
{

			// add one new animated sprite
			sprites[spriteCount] = new Sprite();
			spriteCount++;
	

}

// measure the framerate and add/remove sprites
// depending on how fast we're animating
function checkFPS() 
{
	
		
		// add more sprites if possible
		// only done once per second so we aren't touching
		// the DOM every single frame
		if(sprites.length < 30){
		if(Math.random() < 0.019) {
			//brains.push(Brain());
			maybeMoreSprites();
	
		}
	}
	
}

// update the style as needed
function repositionSprite()
{
	if (!this) return;
	
	// CSS3 version - forces hardware accel on mobile
	// Surprisingly, this is SLOWER on PC Windows using Chrome	
	// but may be faster on iOS and other mobile platforms
	if (use3d && has3d)
	{
		this.style.webkitTransform = 'translate3d('+this.x+'px,'+this.y+'px,0px)';
	}
	else
	{
		this.style.left = this.x + 'px';
		this.style.top = this.y + 'px';
	}
}

// changes the spritesheet frame of a sprite
// by shifting the background image location
function changeSpriteFrame(num)
{
	if (!this) return;
	this.style.backgroundPosition = 
		(-1 * (num % spritesheetXFrames) * spritesheetFrameWidth + 'px ') +
		(-1 * (Math.round(num / spritesheetXFrames) % spritesheetYFrames)) 
		* spritesheetFrameHeight + 'px ';
}

// removes a sprite from a container DOM element
function destroySprite()
{
	if (!this) return;
	this.parent.removeChild(this.element);
}

// the sprite class - DOM sprite version
function Sprite(parentElement)
{
	// function references
	this.reposition = repositionSprite;
	this.frame = changeSpriteFrame;
	this.destroy = destroySprite;
	// where do this sprite live? (default: viewport)
	this.parent = parentElement ? parentElement : viewport;
	// create a DOM sprite
	this.element = document.createElement("div");
	this.element.className = 'sprite';
	// optimized pointer to style object
	this.style = this.element.style;
	// random starting position
// regular sprite in the viewport
	
		this.x = viewportW;
		this.y = Math.round(viewportH/2);

		this.width=32;
		this.height=32;
		
	this.reposition();
	// give it a random speed
	this.xSpeed = Math.round(Math.random() * 10) - 5;
	this.ySpeed = Math.round(Math.random() * 10) - 5;
	// no still sprites
	if (this.xSpeed == 0) this.xSpeed  = 1;
	if (this.ySpeed == 0) this.ySpeed  = 1;
	// random spritesheet frame
	this.frame(spriteCount);
	// put it into the game window
	this.parent.appendChild(this.element);
}



function Mouth(parentElement)
{
this.reposition = repositionSprite;
	// where do this sprite live? (default: viewport)
	this.parent = parentElement ? parentElement : viewport;
	// create a DOM sprite
	this.element = document.createElement("div");
	this.element.className = 'mouth';
	// optimized pointer to style object
	this.style = this.element.style;
	// random starting position
// regular sprite in the viewport
	
		this.x = 50;
		this.y = Math.round(viewportH/2);
		
		this.width=50;
		this.height=100;
		
		this.reposition();
	// put it into the game window
	this.parent.appendChild(this.element);
}








// update the positions of each sprite
function animateSprites()
{
	for (var loop=0; loop < spriteCount; loop++)
	{
		sprites[loop].x += sprites[loop].xSpeed;
		sprites[loop].y += sprites[loop].ySpeed;
		
		// bounce at edges
		if ((sprites[loop].x <= 0) || (sprites[loop].x >= viewportW))
			sprites[loop].xSpeed = -1 * sprites[loop].xSpeed;
		if ((sprites[loop].y <= 0) || (sprites[loop].y >= viewportH))
			sprites[loop].ySpeed = -1 * sprites[loop].ySpeed;
		
		sprites[loop].reposition();
	}
	mouth.reposition();

}

// run each frame
function animate() 
{
	// call this function again asap
	requestAnimationFrame(animate);
	// measure time and add or remove sprites
	checkFPS();
	handleCollisions();
	// bounce the sprites around and scroll the level
	animateSprites();
}

// start your engines!
function startBenchmark()
{
	playbutton.style.display = 'none';
	animate();
	
}

</script>

</body>
</html>
