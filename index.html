<!DOCTYPE html>
<!-- 
	DOM sprite demo
	by Christer Kaitila
	http://mcfunkypants.com
	http://twitter.com/McFunkypants
	http://google.com/+ChristerKaitila
	
	Created for Build New Games (c) 2012 by Bocoup
	http://www.buildnewgames.com
	
	Permission is granted to use this source code
	in any way you wish, commercial or otherwise. Enjoy!
-->
<html lang="en">
<head>
<title>DOM sprite demo</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<style type="text/css">
	body { margin:0; padding:0; border:0; background:black; overflow:hidden; }
	div { position:absolute; margin:0; padding:0; border:0; outline:0; 
		font-family:arial; font-size:12px; color:white; text-align:center; }
	#playbutton { position:absolute; top:50%; left:50%; margin-left:-137px; 
		margin-top:-25px; width:256px; height:32px; padding:16px; border-radius:16px; 
		border:2px solid black; background:#666666; color:white; 
		text-decoration:none; display:block; font-size:32px; line-height:32px; 
		font-family:arial; font-weight:bold; text-align:center; }
	#playbutton:hover { background:red; }
	#viewport { width:100%; height:100%; overflow:hidden; 
		top:0%; left:0%; display:block;}
	#level { width:100%; height:100%; top:0px; left:0px;}
	#background { width:100%; height:100%; top:0px; left:0px; 
		background:url(bgtile.jpg); background-size: 100% 100%; }
	.sprite { background-size:100%;width:10%; height:8%; }
	.mouth {background-color:black;width:3%;height:15%;left:5%;top:45%;}
	#stats {top:5%; left: 5%;}
</style>
<script type="text/javascript" src="jquery-1.6.4.min.js"></script>
<script type="text/javascript" src="jquery-collision.min.js"></script>
</head>
<body>

<div id='viewport' height='480' width='800'><div id='background'><div id='level'><div id="stats"></div></div></div></div>

<a id='playbutton' href='javascript:startBenchmark()'>Click to start</a>

<div id='stats'></div>

<script type='text/javascript'>

// grab the DOM elements we want to manipulate
var viewport = document.getElementById('viewport');
var level = document.getElementById('level');
var background = document.getElementById('background');
var stats = document.getElementById('stats');
var playbutton = document.getElementById('playbutton');
var mouth = new Mouth();
var scaledHeight = $(viewport).height();
var scaledWidth = $(viewport).width();
		
var scaleW = scaledWidth / 800;
var scaleH = scaledHeight / 480;


var score = 0;
				


var detect = false;	


 $(viewport).bind("mousemove", function(event) {	
			if (detect == true)
			mouth.y=event.pageY;
		  });
 $(viewport).bind("mousedown", function(event) {	
			detect = true;
		  });
 $(viewport).bind("mouseup", function(event) {	
			detect = false;
		  });
		 
 $(viewport).bind("touchmove", function(event) {	
			event.preventDefault();

		    var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];

			mouseY = Math.floor(touch.pageY);
			mouth.y=mouseY;
		  });

		   $(viewport).bind("touchstart", function(event) {	
			event.preventDefault();
			detect = true;
		  });
		  
		   $(viewport).bind("touchend", function(event) {	
			event.preventDefault();
			detect = false;

		  });

		 
		  
 function collides(a, b) {
          return a.x < b.x + b.width &&
            a.x + a.width > b.x &&
            a.y < b.y + b.height &&
            a.y + a.height > b.y;
        }
		
function handleCollisions(){
var j =1;
if (j< sprites.length) {

		for (var i = 0; i < sprites.length; ++i) {
			 if((detect == true) && (collides(sprites[i],mouth)) && (sprites[i].active == true)){
					   sprites[i].active = false;
					   sprites[i].style.visibility="hidden";
					   score+=10;
					}
		}

}
 }
// size of the the viewport and the larger level within
var viewportW = viewport.clientWidth;
var viewportH = viewport.clientHeight;

// sprite batches - one for moving sprites 
// and another for static level geometry
var sprites = [];
var spriteCount = 0;




// can this web brower handle CSS3 transforms (to trigger HW accel?)
var has3d = ('WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix());
if (window.console) console.log ('Browser is capable of CSS3 transform3d:'+has3d);
// but should we use it?
var use3d = false;

// ensure that we have requestAnimationFrame
// this is Paul Irish's compatibility shim
if (!window.requestAnimationFrame) 
{
	window.requestAnimationFrame = (function() 
	{
		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function(callback,element) 
		{
			window.setTimeout(callback, 1000 / 60);
		};
	})();
}

// add or remove sprites depending on the FPS
function maybeMoreSprites()
{
			// add one new animated sprite
			sprites[spriteCount] = new Sprite();
			spriteCount++;
}

// measure the framerate and add/remove sprites
// depending on how fast we're animating
function checkFPS() 
{
		// add more sprites if possible
		// only done once per second so we aren't touching
		// the DOM every single frame
		if(spriteCount < 30){
		if(Math.random() < 0.019) {
			//brains.push(Brain());
			maybeMoreSprites();
		}
	}
	
}

// update the style as needed
function repositionSprite()
{
	if (!this) return;
	// CSS3 version - forces hardware accel on mobile
	// Surprisingly, this is SLOWER on PC Windows using Chrome	
	// but may be faster on iOS and other mobile platforms
	if (use3d && has3d)
	{
		this.style.webkitTransform = 'translate3d('+this.x+'px,'+this.y+'px,0px)';
	}
	else
	{
		this.style.left = this.x + 'px';
		this.style.top = this.y + 'px';
	}
}

// changes the spritesheet frame of a sprite
// by shifting the background image location
function changeSpriteFrame(num)
{
	if (!this) return;
	this.style.background = "url('brain2.png')";
}

// removes a sprite from a container DOM element
function destroySprite()
{
	if (!this) return;
	this.parent.removeChild(this.element);
}

// the sprite class - DOM sprite version
function Sprite(parentElement)
{
	// function references
	this.reposition = repositionSprite;
	this.frame = changeSpriteFrame;
	this.destroy = destroySprite;
	// where do this sprite live? (default: viewport)
	this.parent = parentElement ? parentElement : viewport;
	// create a DOM sprite
	this.element = document.createElement("div");
	this.element.className = 'sprite';
	// optimized pointer to style object
	this.style = this.element.style;
	// random starting position
// regular sprite in the viewport
	
		this.x = viewportW;
		this.y = Math.round(viewportH/2);

		this.width=50;
		this.height=38;
		
		this.age = Math.round(Math.random() * 32);
		
		this.active = true;
		
	this.reposition();
	// give it a random speed
	this.xSpeed = -(Math.round(Math.random() * (5 - 2 + 1)) + 2);
	this.ySpeed = 0;
	// no still sprites
	if (this.xSpeed == 0) this.xSpeed  = 1;
	if (this.ySpeed == 0) this.ySpeed  = 1;
	// random spritesheet frame
	this.frame(spriteCount);
	// put it into the game window
	this.parent.appendChild(this.element);
}



function Mouth(parentElement)
{
this.reposition = repositionSprite;
	// where do this sprite live? (default: viewport)
	this.parent = parentElement ? parentElement : viewport;
	// create a DOM sprite
	this.element = document.createElement("div");
	this.element.className = 'mouth';
	// optimized pointer to style object
	this.style = this.element.style;
	// random starting position
// regular sprite in the viewport
	
		this.x = 50;
		this.y = Math.round(viewportH/2);
		
		this.width=50;
		this.height=100;
		
		this.reposition();
	// put it into the game window
	this.parent.appendChild(this.element);
}










// update the positions of each sprite
function animateSprites()
{
	for (var loop=0; loop < spriteCount; loop++)
	{
	
		sprites[loop].ySpeed = Math.round( -2.3 * Math.sin(sprites[loop].age * Math.PI / 50));
		sprites[loop].age++;
		
		sprites[loop].x += sprites[loop].xSpeed;
		sprites[loop].y += sprites[loop].ySpeed;
		
	
		sprites[loop].reposition();
		// bounce at edges


			//sprites[loop].destroy();
		
		
	}
	

}


function clearSprites()
{
var len = sprites.length;
while (len--) {

		if (sprites[len].x < 0 || sprites[len].x > viewportW){
				sprites[len].destroy();
				sprites.splice(len,1);
				spriteCount--;
		}
}

}


// run each frame
function animate() 
{
	// call this function again asap
	requestAnimationFrame(animate);
	// measure time and add or remove sprites
	checkFPS();
	handleCollisions();
	// bounce the sprites around and scroll the level
	animateSprites();
	clearSprites();
    $(stats).html("Score: " + score); 
	mouth.reposition();
}

// start your engines!
function startBenchmark()
{
	playbutton.style.display = 'none';
	animate();
}

</script>

</body>
</html>
