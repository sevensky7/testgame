<!DOCTYPE html>
<!-- 
	DOM sprite demo
	by Christer Kaitila
	http://mcfunkypants.com
	http://twitter.com/McFunkypants
	http://google.com/+ChristerKaitila
	
	Created for Build New Games (c) 2012 by Bocoup
	http://www.buildnewgames.com
	
	Permission is granted to use this source code
	in any way you wish, commercial or otherwise. Enjoy!
-->
<html lang="en">
<head>
<title>DOM sprite demo</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<style type="text/css">
	body { margin:0; padding:0; border:0; background:black; overflow:hidden; }
	div { position:absolute; margin:0; padding:0; border:0; outline:0; 
		font-family:arial; font-size:12px; color:white; text-align:center; }
	#playbutton { position:absolute; top:50%; left:50%; margin-left:-137px; 
		margin-top:-25px; width:256px; height:32px; padding:16px; border-radius:16px; 
		border:2px solid black; background:#666666; color:white; 
		text-decoration:none; display:block; font-size:32px; line-height:32px; 
		font-family:arial; font-weight:bold; text-align:center; }
	#playbutton:hover { background:red; }
	#viewport { width:100%; height:100%; overflow:hidden; 
		top:0%; left:0%; display:block;}
	#level { width:100%; height:100%; top:0px; left:0px;}
	#background { width:100%; height:100%; top:0px; left:0px; 
		background:url(bgtile.jpg); background-size: 100% 100%; }
	.brain {background: url('brain2.png') no-repeat; background-size: 100% 100%; width:12%; height:10%;z-index:11;}
	.candy {background-size: 100% 100%; width:9%; height:15%;z-index:11;}
	.mouth {width:3%;height:15%;left:5%;top:45%;z-index:10;}
	#zombie {background-image: url('img/zombie1.png'); background-size: 100% 100%; width:18%;height:100%;left:2%;top:1%;z-index:9;}
	#stats {top:5%; left: 85%;z-index:0; -webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;}
</style>
<script type="text/javascript" src="jquery-1.6.4.min.js"></script>
<script type="text/javascript" src="jquery-collision.min.js"></script>
</head>
<body>

<div id='viewport' height='480' width='800'><div id='background'><div id='level'><div id="zombie"></div><div id="stats"></div></div></div></div>

<a id='playbutton' href='javascript:startBenchmark()'>Click to start</a>

<div id='stats'></div>

<script type='text/javascript'>

// grab the DOM elements we want to manipulate
var viewport = document.getElementById('viewport');
var level = document.getElementById('level');
var background = document.getElementById('background');
var stats = document.getElementById('stats');
var playbutton = document.getElementById('playbutton');
var mouth = new Mouth();
var zombie = document.getElementById('zombie');
var scaledHeight = $(viewport).height();
var scaledWidth = $(viewport).width();


		
var scaleW = scaledWidth / 800;
var scaleH = scaledHeight / 480;




var score = 0;
				
//----------------------------------------------MOVEMENT

var detect = false;	
var support = Math.round(2.3*mouth.height);

 $(viewport).bind("mousemove", function(event) {	
			if (detect == true){
			mouth.y=event.pageY;
			$(zombie).css('top', mouth.y - support);
			}
		  });
 $(viewport).bind("mousedown", function(event) {	
			detect = true;
			$(zombie).css('background-image', 'url("img/zombie2.png")');
		  });
 $(viewport).bind("mouseup", function(event) {	
			detect = false;
			$(zombie).css('background-image', 'url("img/zombie1.png")');
		  });
		 
 $(viewport).bind("touchmove", function(event) {	
			event.preventDefault();

		    var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];
			if (detect == true){
			mouseY = Math.floor(touch.pageY);
			mouth.y=mouseY;
			$(zombie).css('top', mouth.y - support);
			}
		  });

		   $(viewport).bind("touchstart", function(event) {	
			event.preventDefault();
			detect = true;
			$(zombie).css('background-image', 'url("img/zombie2.png")');
		  });
		  
		   $(viewport).bind("touchend", function(event) {	
			event.preventDefault();
			detect = false;
			$(zombie).css('background-image', 'url("img/zombie1.png")');

		  });

//----------------------------------------------COLLISION DETECTION	 
		  
 function collides(a, b) {
          return a.x < b.x + b.width &&
            a.x + a.width > b.x &&
            a.y < b.y + b.height &&
            a.y + a.height > b.y;
        }
		
function handleCollisions(){
var j =1;
if (j< brains.length) {

		for (var i = 0; i < brains.length; ++i) {
			 if((detect == true) && (collides(brains[i],mouth)) && (brains[i].active == true)){
					   brains[i].active = false;
					   brains[i].style.visibility="hidden";
					   score+=10;
					}
		}
}

if (j< candies.length) {

		for (var i = 0; i < candies.length; ++i) {
			 if((detect == true) && (collides(candies[i],mouth)) && (candies[i].active == true)){
					   candies[i].active = false;
					   candies[i].style.visibility="hidden";
					   score-=10;
					}
		}
}

}
// size of the the viewport and the larger level within
var viewportW = viewport.clientWidth;
var viewportH = viewport.clientHeight;

// sprite batches - one for moving brains 
// and another for static level geometry
var brains = [];
var brainCount = 0;

var candies = [];
var candyCount = 0;


// can this web brower handle CSS3 transforms (to trigger HW accel?)
var has3d = ('WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix());
if (window.console) console.log ('Browser is capable of CSS3 transform3d:'+has3d);
// but should we use it?
var use3d = true;

// ensure that we have requestAnimationFrame
// this is Paul Irish's compatibility shim
if (!window.requestAnimationFrame) 
{
	window.requestAnimationFrame = (function() 
	{
		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function(callback,element) 
		{
			window.setTimeout(callback, 1000 / 60);
		};
	})();
}

// add or remove brains depending on the FPS
function addBrain()
{
			// add one new animated sprite
			brains[brainCount] = new Sprite();
			brainCount++;
}

function addCandy()
{
			// add one new animated sprite
			candies[candyCount] = new Sprite2();
			candyCount++;
}

// measure the framerate and add/remove brains
// depending on how fast we're animating
function addItems() 
{
		// add more brains if possible
		// only done once per second so we aren't touching
		// the DOM every single frame
		if(brainCount < 30){
		if(Math.random() < 0.019) {
			//brains.push(Brain());
			addBrain();
		}
		if(candyCount < 5){
		if(Math.random() < 0.006) {
			//brains.push(Brain());
			addCandy();
		}
		}
	}
	
}

// update the style as needed
function repositionSprite()
{
	if (!this) return;
	// CSS3 version - forces hardware accel on mobile
	// Surprisingly, this is SLOWER on PC Windows using Chrome	
	// but may be faster on iOS and other mobile platforms
	if (use3d && has3d)
	{
		this.style.webkitTransform = 'translate3d('+this.x+'px,'+this.y+'px,0px)';
	}
	else
	{
		this.style.left = (this.x) + 'px';
		this.style.top = this.y + 'px';
	}
}

// changes the spritesheet frame of a sprite
// by shifting the background image location
function changeSpriteFrame(num)
{
	if (!this) return;
	this.style.background = "url('brain2.png') no-repeat";
	this.style.backgroundSize="100% 100%";
}

// removes a sprite from a container DOM element
function destroySprite()
{
	if (!this) return;
	this.parent.removeChild(this.element);
}



// the sprite class - DOM sprite version
function Sprite(parentElement)
{
	// function references
	this.reposition = repositionSprite;
	//this.frame = changeSpriteFrame;
	this.destroy = destroySprite;
	// where do this sprite live? (default: viewport)
	this.parent = parentElement ? parentElement : viewport;
	// create a DOM sprite
	this.element = document.createElement("div");
	this.element.className = 'brain';
	// optimized pointer to style object
	this.style = this.element.style;
	// random starting position
// regular sprite in the viewport
	
		this.x = viewportW;
		this.y = Math.round(viewportH/2);

		scaledHeight = $(viewport).height();
		scaledWidth = $(viewport).width();
		
		this.width=Math.round(scaledWidth*0.15);
		this.height=Math.round(scaledHeight*0.1);
		
		this.age = Math.round(Math.random() * 32);
		
		this.active = true;
		
	this.reposition();
	// give it a random speed
	this.xSpeed = -(Math.round(Math.random() * (8 - 2 + 1)) + 4);
	this.ySpeed = 0;
	// random spritesheet frame
	//this.frame(brainCount);
	// put it into the game window
	this.parent.appendChild(this.element);
}


function Sprite2(parentElement)
{
	// function references
	this.reposition = repositionSprite;
	//this.frame = changeSpriteFrame;
	this.destroy = destroySprite;
	// where do this sprite live? (default: viewport)
	this.parent = parentElement ? parentElement : viewport;
	// create a DOM sprite
	this.element = document.createElement("div");
	this.element.className = 'candy';
	// optimized pointer to style object
	this.style = this.element.style;
	// random starting position
// regular sprite in the viewport

		which_sprite = Math.floor(Math.random() * 2) + 1;
		  
		  if (which_sprite==1){
          this.style.background = "url('img/candy.png') no-repeat";
		  this.style.backgroundSize="100% 100%";
		  }
		  else{
		  this.style.background = "url('img/candy2.png') no-repeat";
		  this.style.backgroundSize="100% 100%";
		  }
	
		this.x = viewportW;
		this.y = Math.round(viewportH/2);

		scaledHeight = $(viewport).height();
		scaledWidth = $(viewport).width();
		
		this.width=Math.round(scaledWidth*0.15);
		this.height=Math.round(scaledHeight*0.1);
		
		this.age = Math.round(Math.random() * 32);
		
		this.active = true;
		
	this.reposition();
	// give it a random speed
	this.xSpeed = -(Math.round(Math.random() * (8 - 2 + 1)) + 2);
	this.ySpeed = 0;
	// random spritesheet frame
	//this.frame(brainCount);
	// put it into the game window
	this.parent.appendChild(this.element);
}



function Mouth(parentElement)
{
	this.reposition = repositionSprite;
	// where do this sprite live? (default: viewport)
	this.parent = parentElement ? parentElement : viewport;
	// create a DOM sprite
	this.element = document.createElement("div");
	this.element.className = 'mouth';
	// optimized pointer to style object
	this.style = this.element.style;
	// random starting position
// regular sprite in the viewport
	
		scaledHeight = $(viewport).height();
		scaledWidth = $(viewport).width();
	
		this.x = Math.round(scaledWidth*0.06);
		this.y = Math.round(viewportH/2);
		
		this.width=Math.round(scaledWidth*0.03);
		this.height=Math.round(scaledHeight*0.15);
		
		this.reposition();
	// put it into the game window
	this.parent.appendChild(this.element);
}






// update the positions of each sprite
function animateSprites()
{
	for (var loop=0; loop < brainCount; loop++)
	{
	
		brains[loop].ySpeed = Math.round( -2.3 * Math.sin(brains[loop].age * Math.PI / 240));
		brains[loop].age++;
		
		brains[loop].x += brains[loop].xSpeed;
		brains[loop].y += brains[loop].ySpeed;

		brains[loop].reposition();	
	}
	
	for (var loop=0; loop < candyCount; loop++)
	{
	
		candies[loop].ySpeed = Math.round( -7 * Math.sin(candies[loop].age * Math.PI / 120));
		candies[loop].age++;
		
		candies[loop].x += candies[loop].xSpeed;
		candies[loop].y += candies[loop].ySpeed;

		candies[loop].reposition();	
	}
}


function clearSprites()
{
var len = brains.length;

	while (len--) {

			if (brains[len].x < 0 || brains[len].x > viewportW){
					brains[len].destroy();
					brains.splice(len,1);
					brainCount--;
			}
	}
	
len = candies.length;

	while (len--){
		if (candies[len].x < 0 || candies[len].x > viewportW){
					candies[len].destroy();
					candies.splice(len,1);
					candyCount--;
			}
	}

}


// run each frame
function animate() 
{
	// call this function again asap
	requestAnimationFrame(animate);
	// measure time and add or remove brains
	addItems();
	handleCollisions();
	// bounce the brains around and scroll the level
	animateSprites();
	clearSprites();
    $(stats).html("Score: " + score); 
	mouth.reposition();
	
}

// start your engines!
function startBenchmark()
{
	playbutton.style.display = 'none';
	animate();
}

</script>

</body>
</html>
